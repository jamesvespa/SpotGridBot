/**
* @file BgwMonitor.h
* @author Helmut <james.doll@bbf-it.at>
* @date 12/1/21
* @version * @copyright (c) 2021 BBF-IT
*/

#ifndef MERCURYUTILS_BGWMONITOR_H
#define MERCURYUTILS_BGWMONITOR_H

#include <vector>
#include <mutex>

namespace UTILS
{

/**
 * Class for monitoring the utilization of BackgroundWorker threads
 */
class BgwMonitor
{
public:
	/**
	 * Constructor
	 */
	BgwMonitor()
			: m_cntThreads(0) { }
	
	using QueueSizeMap = std::map<size_t, int64_t>;

	/**
	 * Result structure generated by monitoring tasks
	 */
	struct Result
	{
		const int64_t totalDuration { 0 }; //!< Duration (in nanoseconds) of monitoring interval
		const std::vector<int64_t> durations; //!< Duration (in ns) per number of used threads
		using QueueSizeMap = std::map<size_t, int64_t>;
		const QueueSizeMap queueSizeMap; //!< Map queue size -> duration
		
		bool Valid() const; //!< Is this result struct valid?
		
		double BusyRate() const; //!< Fraction [0..1] of @a totalDuration when at least one thread was busy
		double FullyOccupiedRate() const; //!< Fraction [0..1] of @a totalDuration when all threads were busy
		double AverageUtilization() const; //!< Percentage of thread utilization during the time when at least one thread was busy
		
		size_t MinQueueSize() const; //!< Minimum queue size stored in the queue size map
		size_t MaxQueueSize() const; //!< Maximum queue size stored in the queue size map
		double AvgQueueSize() const; //!< Time-weighed average of queue sizes stored in the queue size map
	};
	
	/**
	 * This class represents a monitoring task
	 */
	class Task
	{
		/**
		 * Grant access to private members to enclosing class @a BgwMonitor.
		 *
		 * @a UpdateBusyThreads() is called by @a BgwMonitor, but should not
		 * be visible from outside.
		 */
		friend class BgwMonitor;
	
	public:
		using Ptr = std::shared_ptr<Task>; //!< Alias for shared pointer to Task
		
		/**
		 * Constructor
		 * @param maxThreads Number of available threads
		 * @param busyThreads Number of threads that are currently in use
		 * @param queueSize (optional) Current queue size; if @a std::nullopt -> no queue size monitoring
		 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of task creation (default: current time)
		 */
		Task(size_t maxThreads, size_t busyThreads, std::optional<size_t> queueSize, int64_t timestamp);
		
		bool IsActive() const; //!< Is this task currently active?
		
		void Stop(); //!< Stop (deactivate) this task
		
		/**
		 * Returns the current result and resets all counters
		 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of result (default: current time)
		 * @return @a Result structure
		 */
		Result GetResultAndReset(int64_t timestamp = 0);
		
		/**
		 * FOR TESTING ONLY: Get current values of private data members
		 *
		 * @param active (out) Is this task currently active?
		 * @param firstStart (out) Starting timestamp (in nanoseconds epoch time) of the monitoring interval
		 * @param latestStart (out) Timestamp (in nanoseconds epoch time) of the latest update
		 * @param currentBusy (out) Number of threads currently busy
		 * @param durations (out) Vector of durations (in ns) per number of busy threads
		 * @param queueSizeMap (out) Map of durations per queue size
		 */
		void TestOnlyGetMembers(bool &active, int64_t &firstStart, int64_t &latestStart, size_t &currentBusy, std::vector<int64_t> &durations,
								QueueSizeMap &queueSizeMap) const;
	private:
		
		mutable std::mutex m_mtx; //!< Mutex for thread-safe access
		bool m_active; //!< Is this task currently active?
		int64_t m_firstStart; //!< Starting timestamp (in nanoseconds epoch time) of the monitoring interval
		int64_t m_latestStart; //!< Timestamp (in nanoseconds epoch time) of the latest update
		size_t m_currentBusy; //!< Number of threads currently busy
		std::vector<int64_t> m_durations; //!< Vector of durations (in ns) per number of busy threads
		
		/**
		 * Updates the number of busy threads. Called only by BgwMonitor class
		 *
		 * @param busyThreads Number of busy threads
		 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of update (default: current time)
		 * @return @a true if update was successful
		 */
		bool UpdateBusyThreads(size_t busyThreads, int64_t timestamp = 0);
		
		const bool m_monitorQueueSize; //!< @a true -> queue size will be monitored, @a false -> skip queue size monitoring
		int64_t m_latestQueueSizeUpdate; //!< Timestamp (in nanoseconds epoch time) of the latest queue size update
		size_t m_currentQueueSize; //!< Current queue size
		QueueSizeMap m_queueSizeMap; //!< Map queue size -> duration
		
		/**
		 * Updates the queue size. Called only by BgwMonitor class
		 *
		 * @param queueSize New queue size
		 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of update (default: current time)
		 * @return @a true if number of threads was updated successfully
		 */
		bool UpdateQueueSize(size_t queueSize, int64_t timestamp = 0);
		
		/**
		 * Low-level update of queue size map
		 *
		 * @param queueSize Queue size entry to be updated in the map
		 * @param duration Duration to be added to to the queue size entry in th emap
		 */
		void UpdateQueueSizeMap(size_t queueSize, int64_t duration);
	};
	
	/**
	 * Starts monitoring.
	 *
	 * Monitoring task can be created only after monitoring was started successfully.
	 *
	 * @param cntThreads Number of avalaible threads
	 * @return @a true if monitoring was started, @a false on failure
	 */
	bool Start(size_t cntThreads);
	
	/**
	 * Stops monitoring.
	 *
	 * All monitoring tasks are deactivated and will not generate valid results.
	 *
	 * @return @a true if monitoring was stopped successfully
	 */
	bool Stop();
	
	/**
	 * Creates and starts a new monitoring task
	 *
	 * Full constructor with explicit timestamp - FOR TESTING PURPOSES ONLY
	 *
	 * @param busyThreads Number of currently busy threads
	 * @param queueSize (optional) Current queue size; if @a std::nullopt -> no queue size monitoring
	 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of task creation (default: current time)
	 * @return @a Pointer to new monitoring task, @a nullptr on failure
	 */
	BgwMonitor::Task::Ptr StartTask(size_t busyThreads, std::optional<size_t> queueSize, int64_t timestamp);
	
	/**
	 * Creates and starts a new monitoring task (with queue size monitoring)
	 * @param busyThreads Number of currently busy threads
	 * @param queueSize Current queue size
	 * @return @a Pointer to new monitoring task, @a nullptr on failure
	 */
	BgwMonitor::Task::Ptr StartTask(size_t busyThreads, size_t queueSize) { return StartTask(busyThreads, queueSize, 0); }
	
	/**
	 * Creates and starts a new monitoring task (without queue size monitoring)
	 * @param busyThreads Number of currently busy threads
	 * @return @a Pointer to new monitoring task, @a nullptr on failure
	 */
	BgwMonitor::Task::Ptr StartTask(size_t busyThreads) { return StartTask(busyThreads, std::nullopt, 0); }

	
	bool IsActive() const; //!< Is monitoring active?
	
	/**
	 * Execute an action for every task that is managed by the BgwMonitor
	 *
	 * NOT THREAD-SAFE - m_mtx has to be locked by caller
	 *
	 * @tparam A Function type of action to be executed; signature: void(Task &)
	 * @param action Action to be executed for each task
	 */
	template <typename A>
	void ForEachTaskDo(A action)
	{
		for (auto it { m_tasks.begin() }; it != m_tasks.end();)
		{
			Task &task { **it };
			if (task.IsActive())
			{
				action(task);
				++it;
			}
			else
			{
				it = m_tasks.erase(it);
			}
		}
	}
	
	/**
	 * Updates the number of idle threads.
	 *
	 * This function is called by the BackgroundWorker
	 *
	 * @param idleThreads Number of currently idle threads
	 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of update (default: current time)
	 * @return @a true if number of threads was updated successfully
	 */
	bool UpdateIdleThreads(size_t idleThreads, int64_t timestamp = 0);
	
	/**
	 * Updates the queue size.
	 *
	 * @param queueSize New queue size
	 * @param timestamp (optional; FOR TESTING PURPOSES ONLY) Timestamp of update (default: current time)
	 * @return @a true if number of threads was updated successfully
	 */
	bool UpdateQueueSize(size_t queueSize, int64_t timestamp = 0);
	
//private:
protected: // has to be visible for unit testing
	
	mutable std::mutex m_mtx;
	size_t m_cntThreads; //!< Number of available threads
	
	std::vector<Task::Ptr> m_tasks; //!< Vector of tasks
};

} // namespace UTILS

#endif //MERCURYUTILS_BGWMONITOR_H
